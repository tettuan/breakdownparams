# テスト仕様

## テスト設計原則

テストは以下の原則に従って設計されています：

1. **段階的な複雑性**
   - 基本機能から始まり、徐々に複雑なユースケースへと進む
   - 各段階で必要な前提条件が満たされていることを確認
   - 前段階のテストが成功していることを前提とする

2. **階層的な構造**
   - 基礎テスト（基本機能の検証）
   - コア機能テスト（中核となる機能の検証）
   - 単体機能テスト（個別機能の検証）
   - 連携機能テスト（機能間の連携検証）
   - 統合テスト（全体の動作検証）

3. **番号による順序付け**
   - テストファイル名に番号を付与（例：`01_basic_test.ts`）
   - 番号は実行順序を表す
   - 依存関係を明確に示す

4. **実行順序の保証**
   - 番号順にテストが実行される
   - 前段階のテストが成功していることを確認
   - 依存関係に基づいた実行順序の制御

## テストディレクトリ構造

```
tests/
├── 01_basic/                    # 基礎テスト
│   ├── 01_no_params_test.ts     # パラメータなしのテスト
│   └── 02_single_param_test.ts  # 単一パラメータのテスト
│
├── 02_core/                     # コア機能テスト
│   └── 01_double_params_test.ts # 2パラメータのテスト
│
├── 03_unit/                     # 単体機能テスト
│   ├── 01_options_test.ts       # オプション処理のテスト
│   └── 02_extended_params_test.ts # 拡張パラメータのテスト
│
├── 04_integration/              # 連携機能テスト
│   └── 01_error_test.ts         # エラー処理のテスト
│
└── 05_e2e/                      # 統合テスト
    └── 01_params_parser_test.ts # パラメータパーサーの統合テスト
```

## テスト階層構造

テストは以下の階層構造に従って実装されています：

1. **基礎テスト** (`01_basic/`)
   - `01_no_params_test.ts`: パラメータなしのケース
   - `02_single_param_test.ts`: 単一パラメータのケース

2. **コア機能テスト** (`02_core/`)
   - `01_double_params_test.ts`: 2パラメータのケース

3. **単体機能テスト** (`03_unit/`)
   - `01_options_test.ts`: オプション処理の基本機能
   - `02_extended_params_test.ts`: 拡張パラメータの機能
     - 拡張モードの有効/無効
     - DemonstrativeTypeの拡張設定
     - LayerTypeの拡張設定
     - カスタムバリデーションルール
     - エラーメッセージのカスタマイズ

4. **連携機能テスト** (`04_integration/`)
   - `01_error_test.ts`: 各種エラーケースの検証

5. **統合テスト** (`05_e2e/`)
   - `01_params_parser_test.ts`: パーサーの統合的な動作確認

### テストの依存関係

テストは以下の順序で実行されます：

1. 基礎テスト (`01_basic/`)
   - 01: パラメータなし
   - 02: 単一パラメータ

2. コア機能テスト (`02_core/`)
   - 01: 2パラメータ

3. 単体機能テスト (`03_unit/`)
   - 01: オプション処理
   - 02: 拡張パラメータ処理

4. 連携機能テスト (`04_integration/`)
   - 01: エラー処理

5. 統合テスト (`05_e2e/`)
   - 01: パーサー統合


## テスト実行手順

### 推奨: 一括テスト・CIフローのローカル実行

プロジェクト全体のテスト・フォーマット・Lintチェックを一括で実行するには、以下のスクリプトを利用してください。

```bash
deno task ci
```

- CIと同等のフローをローカルで再現します。
- すべての *_test.ts を順に実行し、テスト通過後にフォーマット・Lintチェックを行います。
- エラー時は `LOG_LEVEL=debug deno task ci` で詳細なデバッグ出力が得られます。
- テストは依存順（番号順）で実行されます。
- コミット・プッシュ・マージ前に必ずこのスクリプトで全チェックを通過させてください。

### 特定のテストファイルの実行

```bash
deno test <test_file.ts> --allow-env --allow-write --allow-read --allow-run
```

## デバッグ出力

BreakdownLogger をテストコードで「のみ」利用する。
メインコードにデバッグ出力を加える際は、BreakdownLogger を使わず、後で削除できるように明示的に console.debug( "[DEBUG]" ) を記載すること。

### テストコードでの使用

```typescript
import { BreakdownLogger } from "@tettuan/breakdownlogger";

const logger = new BreakdownLogger();
logger.debug("テスト実行開始", { testName: "example" });
```

### ログレベル

- `debug`: 詳細なデバッグ情報
- `info`: 重要な処理の開始/終了
- `warn`: 警告（回復可能なエラー）
- `error`: エラー（処理中断）

## エラー処理とデバッグ

### エラー発生時の調査手順

1. デバッグログの確認
2. テスト環境の状態確認
3. 関連するテストケースの実行
4. エラー再現手順の文書化

### テスト失敗時の対応

1. エラーメッセージの確認
2. デバッグモードでの再実行
3. 関連する実装の確認
4. テスト失敗の前処理判定
5. 修正と再テスト

### テスト失敗の前処理判定

- テストの目的ではない前処理で失敗した場合、別の処理前のテストが必要。
- 前処理のテストは local_ci.sh で先に実行済みとなるように、実行順を前段階で配置する。
- 前処理の例：
  - 設定判定のテストだが設定ファイルの読み込みに失敗する
    - 設定ファイルの読み込みテストを作る
- 前処理ではない例:
  - 設定判定のテストで設定値が一致しないため失敗する
- テストの前処理は、該当テストより前に実施された確認済みプロセスを利用すること。後工程のテストが独自実装しないことが重要。

# スケルトンコードの構築順序(テスト駆動)

- 「テストディレクトリ構造」に従い、テストファイルを作成する
- スケルトンの作成：テスト項目を、先にテスト対象として記述する（まだテストの内容は書かない）
- スケルトンには、テストが失敗する記述を入れておく
- コメントを記載する
  - あなたが他人のコードを読んだときに「知りたい」と思うことを記載する
  - テストの意図や目的、テストした方が良いと考えた理由を記述する
  - テストが扱う対象を明記する
